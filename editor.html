<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>KAnki Editor (Static, No Backend)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
:root {
  /* Dark Mode (Default) */
  --bg: #1a1d2e;
  --card: #252836;
  --ink: #e4e5e9;
  --muted: #9597a1;
  --line: #363a4d;
  --accent: #ff9d3d;
  --accent-hover: #ffb366;
  --accent-text: #ffffff;
  --panel: #2a2d3e;
  --kindle-bg: #2d3142;
  --kindle-header: #353849;
  --kindle-border: #4a4d62;
  --kindle-button: #b8bac4;
  --kindle-hard: #c5c7d1;
  --kindle-good: #a8aab5;
  --kindle-easy: #8b8d98;
  --kindle-again: #dfe0e5;
  --shadow-sm: 0 2px 4px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 8px rgba(0,0,0,0.4);
  --shadow-lg: 0 4px 12px rgba(0,0,0,0.2);
  --transition: all 0.2s ease-in-out;
  --device-border: #333;
  --device-shadow: rgba(28, 35, 64, 0.25);
  --toast-bg: rgba(32, 49, 90, 0.95);
  --toast-text: #ffffff;
  --edit-highlight: #2a3a4a;
  --danger-bg: #4a2828;
  --danger-text: #ff6b6b;
  --danger-border: #5a3535;
  --danger-hover-bg: #5a3030;
  --delete-btn: #cc5555;
  --modal-backdrop: rgba(14, 18, 36, 0.4);
  --loading-spinner: #888888;
  --badge-bg: #ff9d3d;
  --badge-text: #ffffff;
  --star-active: #ffb366;
}

/* Light Mode Colors */
:root[data-theme="light"] {
  --bg:#f0f2f7;
  --card:#fff;
  --ink:#1a2135;
  --muted:#6b7385;
  --line:#d7dbea;
  --accent:#4267d9;
  --accent-hover:#3555c3;
  --accent-text: #ffffff;
  --panel:#f9faff;
  --kindle-bg: #f5f5f5;
  --kindle-header: #eaeaea;
  --kindle-border: #ccc;
  --kindle-button: #555555;
  --kindle-hard: #444444;
  --kindle-good: #666666;
  --kindle-easy: #888888;
  --kindle-again: #222222;
  --shadow-sm: 0 2px 4px rgba(0,0,0,0.05);
  --shadow-md: 0 4px 8px rgba(0,0,0,0.08);
  --shadow-lg: 0 4px 12px rgba(0,0,0,0.1);
  --device-border: #bbb;
  --device-shadow: rgba(0, 0, 0, 0.15);
  --toast-bg: rgba(26, 33, 53, 0.92);
  --toast-text: #ffffff;
  --edit-highlight: #e3f2fd;
  --danger-bg: #fff5f5;
  --danger-text: #c53030;
  --danger-border: #feb2b2;
  --danger-hover-bg: #fed7d7;
  --delete-btn: #dc3545;
  --modal-backdrop: rgba(0, 0, 0, 0.3);
  --loading-spinner: #4267d9;
  --badge-bg: #4267d9;
  --badge-text: #ffffff;
  --star-active: #fbbf24;
}

* { box-sizing: border-box; }
html, body { margin:0; padding:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; color:var(--ink); }
body { display:flex; min-height:100vh; background:var(--bg); flex-direction: column; }

/* Page Wrapper */
.page-wrapper { display:flex; flex:1; min-width:0; }

/* Layout */
#sidebar { width:250px; min-width:200px; background:var(--card); border-right:1px solid var(--line); display:flex; flex-direction:column; box-shadow: var(--shadow-sm); z-index: 2; }
#topbar { height:56px; display:flex; align-items:center; justify-content:space-between; padding:0 14px; border-bottom:1px solid var(--line); background:var(--panel); position:sticky; top:0; z-index:5; box-shadow: var(--shadow-sm); }
#topbar .title { font-weight:700; color:var(--ink); letter-spacing:.2px; }
#topbar .actions { display:flex; gap:8px; }
button { cursor:pointer; border:1px solid var(--line); background:var(--card); color:var(--ink); padding:8px 10px; border-radius:8px; font-weight:600; transition: var(--transition); }
button:hover { background:var(--panel); transform: translateY(-1px); box-shadow: var(--shadow-sm); }
.btn-primary { background: var(--accent); color:var(--accent-text); border-color:var(--accent); }
.btn-primary:hover { background: var(--accent-hover); border-color: var(--accent-hover); box-shadow: var(--shadow-sm); }
.btn-danger { background:var(--danger-bg); color:var(--danger-text); border-color:var(--danger-border); }
.btn-danger:hover { background:var(--danger-hover-bg); }
.btn-ghost { background:var(--card); color:var(--ink); border-color:var(--line); }
.btn-ghost:hover { background:var(--panel); }
.btn-small { padding:5px 9px; border-radius:6px; font-size:.92em; }

#deckListWrap { padding:10px 10px 14px; overflow:auto; flex: 1; }
.deckHeader { font-weight:700; color:var(--ink); margin:12px 6px 10px; letter-spacing: 0.3px; }
#deckList { list-style:none; margin:0; padding:0; }
.deckItem { display:flex; align-items:center; gap:6px; padding:9px 12px; border-radius:8px; margin-bottom: 2px; transition: var(--transition); }
.deckItem:hover { background:var(--panel); }
.deckItem.selected { background:var(--accent); color:var(--accent-text); font-weight:700; }
.deckItem .spacer { flex:1; }
.deckItem .del { color:var(--delete-btn); border:none; background:none; font-size:1.05em; opacity: 0.7; transition: var(--transition); }
.deckItem .del:hover { opacity: 1; transform: scale(1.1); }
.deckFoot { padding:10px; border-top:1px solid var(--line); background: var(--panel); }

/* Main */
#main { flex:1; display:grid; grid-template-columns: 1fr 1fr; gap:0; min-width:0; }
#cardsPane { display:flex; flex-direction:column; min-width:0; box-shadow: var(--shadow-sm); z-index: 1; background: var(--bg); }
#cardsBar { height:56px; display:flex; align-items:center; gap:10px; padding:0 16px; border-bottom:1px solid var(--line); background:var(--card); position:sticky; top:0; z-index:4; box-shadow: var(--shadow-sm); }
#cardsBar .levelTitle { font-weight:800; color:var(--ink); letter-spacing:.2px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
#cardsList { flex:1; overflow:auto; padding:10px; scroll-behavior: smooth; }
.row { display:grid; grid-template-columns: 30px 30px 1.2fr 1.6fr .8fr .6fr; gap:10px; align-items:center; padding:12px; margin:8px 0; background:var(--card); border:1px solid var(--line); border-radius:10px; transition: var(--transition); box-shadow: var(--shadow-sm); }
.row:hover { transform: translateY(-2px); box-shadow: var(--shadow-md); }
.row.selected { outline:2px solid var(--accent); background: var(--panel); }
.row.visible { background: var(--panel); }
.cell { min-width:0; overflow:hidden; text-overflow:ellipsis; color:var(--ink); padding: 4px 0; }
.cell.muted { color:var(--muted); }
.row .actions { display:flex; gap:6px; justify-content:flex-end; }
#cardsFoot { padding:12px 16px; border-top:1px solid var(--line); background:var(--card); }

/* Preview */
#previewPane { border-left:1px solid var(--line); background:var(--bg); display:flex; flex-direction:column; min-width:0; overflow:hidden; box-shadow: var(--shadow-sm) inset; }
#previewBar { height:56px; display:flex; align-items:center; justify-content:space-between; gap:10px; padding:0 14px; border-bottom:1px solid var(--line); background:var(--panel); position:sticky; top:0; z-index:4; box-shadow: var(--shadow-sm); }
#deviceSel { padding:6px 10px; border-radius:8px; border:1px solid var(--line); background:var(--card); color:var(--ink); box-shadow: var(--shadow-sm); transition: var(--transition); }
#deviceSel:hover, #deviceSel:focus { border-color: var(--accent); outline: none; box-shadow: 0 1px 4px rgba(66, 103, 217, 0.2); }
#previewHost { flex:1; display:flex; align-items:flex-start; justify-content:center; padding:20px; overflow:auto; }
#previewHost #device { position: sticky; top: 20px; }

/* Kindle Device Styles */
#device {
  background:var(--kindle-bg);
  border-radius:5px;
  border:1px solid var(--device-border);
  box-shadow:0 10px 28px var(--device-shadow);
  overflow:hidden;
  display:flex;
  flex-direction:column;
  position:relative;
  transform-origin:center;
  filter: grayscale(1);
  transition: transform 0.3s ease-out;
}

/* KAnki App Styles */
#headerBar {
  margin:0;
  padding:0;
  border-bottom:1px solid var(--kindle-border);
  background-color:var(--kindle-header);
}

.topBar {
  width:100%;
  display:table;
  table-layout:fixed;
  border-spacing:0;
  padding:5px 10px;
  background-color:var(--kindle-header);
}

.logoArea {
  display:table-cell;
  width:25%;
  text-align:left;
  vertical-align:middle;
}

.infoArea {
  display:table-cell;
  width:75%;
  text-align:right;
  vertical-align:middle;
  padding-right:15px;
  overflow:hidden;
  text-overflow:ellipsis;
}

#title {
  margin:0;
  padding:5px 0;
  font-size:1.6em;
  text-align:left;
}

.menuBar {
  width:98%;
  margin:0 auto;
  padding:5px 0;
  text-align:center;
  display:table;
  table-layout:fixed;
  border-spacing:0;
  border-top:1px solid var(--kindle-border);
}

.menuSection {
  display:table-cell;
  vertical-align:middle;
  text-align:center;
}

.menuDivider {
  display:table-cell;
  width:10px;
}

#mainContainer {
  background-color:var(--kindle-bg);
  height:calc(100% - 106px);
  overflow:auto;
  position:relative;
}

.card {
  background-color:var(--kindle-bg);
  border-radius:5px;
  box-shadow:0 2px 4px rgba(0,0,0,0.1);
  padding:20px;
  margin:20px auto;
  width:80%;
  position:relative;
  min-height:300px;
  border:1px solid var(--kindle-border);
  color: var(--kindle-button);
}

.levelBadge {
  position:absolute;
  top:10px;
  right:10px;
  background-color:var(--badge-bg);
  color:var(--badge-text);
  padding:3px 8px;
  border-radius:3px;
  font-size:0.8em;
}

.starButton {
  position:absolute;
  top:10px;
  left:10px;
  background:none;
  border:none;
  font-size:1.5em;
  cursor:pointer;
  z-index:10;
  padding:5px;
  color:var(--muted);
}

.starButton.starred {
  color:var(--star-active);
}

.cardFront {
  font-size:2em;
  font-weight:bold;
  margin-bottom:20px;
  margin-top:15px;
  min-height:60px;
  font-family:'LanguageFont', sans-serif;
  white-space: pre-wrap;
  line-height: 1.25em;
  padding: 20px 24px 8px;
  word-break: break-word;
  overflow-wrap: break-word;
  max-width: 100%;
}

.cardBack {
  font-size:1.5em;
  margin-bottom:10px;
  padding-top:15px;
  border-top:1px solid var(--kindle-border);
  min-height:50px;
  white-space: pre-wrap;
  line-height: 1.25em;
  padding: 15px 24px 8px;
  word-break: break-word;
  overflow-wrap: break-word;
  max-width: 100%;
}

.cardNotes {
  font-size:0.9em;
  color:var(--muted);
  font-style:italic;
  white-space: pre-wrap;
  line-height: 1.25em;
  padding: 2px 24px 16px;
  word-break: break-word;
  overflow-wrap: break-word;
  max-width: 100%;
}

.cardStats {
  font-size:0.7em;
  color:var(--muted);
  text-align:right;
  margin-top:15px;
  padding-top:5px;
  border-top:1px dashed var(--kindle-border);
  font-style:italic;
  white-space: pre-wrap;
  line-height: 1.25em;
  padding: 5px 10px;
  word-break: break-word;
  overflow-wrap: break-word;
  max-width: 100%;
}

.buttonContainer {
  text-align:center;
  margin:20px 0;
}

.buttonContainer button {
  margin:0 5px;
  padding:5px 10px;
  border:1px solid var(--kindle-border);
  border-radius:0;
  background-color:var(--kindle-bg);
  color: var(--kindle-button);
}

#showAnswerBtn {
  padding:12px 25px;
  margin:8px auto;
  font-size:1.1em;
  cursor:pointer;
  border:1px solid var(--kindle-border);
  min-width:80%;
  display:block;
  border-radius:0;
  background-color:var(--kindle-bg);
  color: var(--kindle-button);
}

#intervalButtons {
  text-align:center;
  width:100%;
  height:auto;
}

.intervalBtn {
  padding:8px 12px;
  margin:0 5px;
  font-size:0.95em;
  cursor:pointer;
  border:1px solid var(--kindle-border);
  min-width:60px;
  display:inline-block;
  border-radius:0;
}

.againBtn {
  background-color:var(--kindle-again);
  color:white;
  font-weight:bold;
  border-width:2px;
  min-width:75px;
}

.hardBtn {
  background-color:var(--kindle-hard);
  color:white;
}

.goodBtn {
  background-color:var(--kindle-good);
  color:white;
}

.easyBtn {
  background-color:var(--kindle-easy);
  color:white;
}

.footer {
  text-align:center;
  margin-bottom:20px;
  font-size:0.8em;
  color:var(--muted);
}

/* Create virtual font for preview */
@font-face {
  font-family:'LanguageFont';
  src:url('data:font/woff2;base64,d09GMgABAAAAABesAA4AAAAAMXgAABdUAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmAAghIIDAmXFxEICrIIoEALcgABNgIkA4NsBCAFhAoHhHkbWStRlHKSHrIvsE0iWVVrYVHRF2NFG+wGGkFFRUVMTJRF9q7j2V12Y0cFjWlN8vz8/nPuBfKPy1FE2wYR0W2gqS2wYrEGw7WBSFl6k51UR6XS0E7bLo+l6NZQx8FQLvfDLtd++UENUQkldvxOxZ9Kp65U1ExUdGrRdRrTzDKTVCaZIZFXzP/zu3X/3vsDkKANDxpIQoQCZmjWtDWtVo0KWsXXRVRGP5TZK1rZf9FljI1C5pYbm5Wlv22/BQEYBB4wKgygH//fNr0WF24lB6CK21l5tbr1F3y8uQm4MBlC4kCZZHdICUJJFExmGe8/M9X8mmTJAr2sJFlSJq22sTHX3L1773/6g25Vg9pntoLJUtWupLZgZaLxkHZlsunTphZHUF9ohH/nztgK7XsEjqHQ7EjZ2dVxm9XdNzMVhCQSBhfS7t37ThBFwgQiRAwxIkwIhjwwcgCiMQnSqhUlCohBvfr6ZkL/Ae4ZUHDB3Y9SFWpoDQSTLMeFABBBhgZSW33dfJIAqIq1VQAwAJQApfRKuIGBsqvjXtPLcSzgMQHjAMoAsgR16o8AKGWuZwGSJGkAmIQgCJBcQVSJq/xIj55BYmKKRiJKdpDkMAZHJ+EJKZXWKamM9AwsHBkxXkEYE5dP0DOkZTSysnPzCopKRSWVckVVXaNx3Rh59969x6bvdkCLYvBh82EnXHfDLXfcd8ddTzz0xCuvvfXGO+999I41KA1Gg9tgsziPu1bQUiJuEiShX8Wl3qjGZOXr9zzr33/HBl5A7H3mDtPeHj1zfQ8XzSuvvfXGO++999GaRJOsmWWxLQfIBTjcPrvkIQl9JHSQ0EkAqaEXENYXeOK193DXKxu3DQvmOXfMFwj0AJgHFADAUwCMZNJkmAQOEQJiYBzEQhYQCdggAEqhH/KwDWXYg0rsBwfWoAzrqBp9jEORK82jYvqm99ETGZILDTrV6VSnU512de2+jdcG9ZlrUZUhNRnSoFY92nVpbG4YGx0aHR4cH+no6OxQXdp1alCrHvUZ0mDV5Hp9+jVob9Gjt8OcevXu261Tn8YMadSoSpsmbbQxGzOoRZMGVRmyvXWv/q5mLcwyhxk0KUa9OjPF67+/dRXeV3vOkLZP+zWzvLx/l/QcKCeRMI4wfUQWkM8pPJJCLRUYgUkz7Eev+LXFdTzPj+N4ftpBGkMxlMJCIAJIgEK4dMW1YbHoK7o8/8NRPnEyR6CyODw+n8fn8wcGi0MkFIklUplcrVabzRarze5wutwS6Vx/QIiPQ1nqCfGL6B0UEtbXPzA0khqWkZmenZ9XmD8+MWXG4mLxTUzO3rnz4Nmz5zdv3jr06NrNw4fufv/diy8OvT5y9B2r73/8dPX3n5fN/fv7Yz/+ePfX38B//xSCZcKnvPnUDqUvTHnbCqnw6bNn1Mmy8/EqYNJnk6HRPt6Y69dv/b+2ZhwAGU9z65ffp7z9PHxTytsAkKhxQVHkR05y49JTI/5fMmgAmJM2gvKBrDz0Sz32gy55BLhR2vfIa++9hyjjBWzK6ySIo7vTVEKZHMFGXwA3B/NyjgiQh6lD6AMCwYCIx7yGw2EehyADJM4FwAB8aMSZIFAhDQRMw8AUbAwM2GAAhUcOcGQGCJAJI0GghjljQICCqAjYESAg5FLLSQVAqGfIYVJvgPMMG6Yg3cAgwsSPLVcqtTIwl1KAUyMkE5M6gZIIZVJ5MNwZ0JqVcEYQCqX0YcEVZqKTEwnEMBFwh6EciWExs1Ev40XVBaVUQ57oSmtOUBQYqQClUwojDq4yAA/LcQ5RDVEwwkDI4w7PYVBHA8+l+Fxgkgom6VCMZpWpO4K3JD6EBAcLZVGKVZNRbiqpwqSuLBBQRdmFGBdXWAwZpE4gmWTj0AmlXCPzpAkQPCrIEiKOXSLrBCVZoiOjxQkkTBBGlI6qmWzpRZt1cXVUTwlCDfJI4WApNYYBhO+JSjlAyICKEPBMSYHp06hASYRQN4cgMQD3MsgKqvNKiWfIGcChcQCn58LoWAAHpoUd3ZMxHwOoE31YNHWVKJbVmKgQMNLJrT6cGXFGpOlQIIgxUSxjVZcRNW0VjzMJnAHPFLlcIQ0+CxKHGU6RxcpWKHfFQQEFolVmlRAKTzlzBCWZEA8FiRuGfhROG8WCsRXEJlJKJYbQpkIrS+Y0SBKnMGzOKoU4NkpRRhTLuARhlpfJSlYHSHKNXErRQI2qiJVS9rG50mTXy1kHV1gUd5QkmDCcWdaXq+QKJ7QqgSAI1FyZdoWlEBkm8S5cYmL41bRAEFKnJkC2Mmg6pM7O2JJyZRQeXLaR62D6qDbKwgcklKNV+DQPz6UwPtPn5JnAR6o1pXOjp0MFnQE0UudiB9EYKPSJtFNtTjUXSxYNmQkC+lKDtA9NrXkR9tP8WqiA5CmELVVqzBXlnUkzFB1tRXuWzSZtHj5QlnKB2bJ0aMc+UrVOjlqT0hRYbZDkfcgMHCCELQpU2aAipgQfSOdCQSX6gMCIImvbYlXpJlCHxiDZGaZLPcjbIRWQOb1R07lRJ2PIdFgGbYrUZ9QFIC07IGGSWg3Cs7RNRq8CoBhxZDFijExjHJ0FZyoIcuFGBzv5rsFBVD+qRfKEPKfzC9BKjXNBhJ1jzKYm2UMkDNmUbKLSWxEGxZVyIbE4xLoxqbJoLdDBMJWNMXhDxXKj1CKfKK6ASFgwNnLFOJxJzREQVsKdJGgkMuqKiiHLSFxRIZGY1ImolZJU4LwBY9QMJQKZUQTUI0hVkLLMcjUMwFJaKAHmUmJgcKFR7XCnxYohSkmpwDDIBTAFFDotYzXIFzCPJtNmzUEokHnGGjJHZxWoDkpSihAkS6kXQtDpMVcCG9FnCdaG0ySgWQeN/EuASmVEZDZ6U2M+QmKplPH8DGgtl1O1EKCNcQVcV7IuozNEGaKqETAklZvZTK03GgplhcQy+pCIY1fSihxFRh1v1s1R7e1FnBGBQJjAc0VJZaRiFWdcD/IzRwqGQ4VYpiCkYwCnE1aCITRwKRhbOcfnOtFGaxBZQk45Z7EqnKZIo6u6bIFUVTKtImIHJjdSBZxoRZ0hg1gLZsyUawwlCr0WZpyiSRxFkgwSM4NEI00pDKYOJfO9J5VBJhHPp3I8V7JyNZfI5RqWxGKoS2O5mTFSYpQgKKMxXGJgiiWSSgXM2NKlCSoiY5X5vN2aYsXYZ9VaLOsMLFkG2G7nrbaI3TrFYUW7JeEEpdRSsZj4yMICDFvMKi+PtYrFuVOvx44e2xpTHuBnGQwUAHCnZsMO8uHJGw/efnXuyuGLl698cfcWGGZcmcg4LNTHDfuFAcBm+yLsvbDjwMMl8iMCo7Y6DiBgcQABdmOjIGDsBwx4Duj/w4Ld9g3rL9lUBtjMDVtYJQCYJXeXHYLbAMC8FAaS+IcZQeJVICRxdGI2AbMASQr1HKwEkqwCEU0LD71hDTOZjbMFRhaBSAwDkA0yYwWQRAvBVh1XA0lswCIgSRasApKCWKkKJOVxFZD0EUjTTFLQN5QRk5LZbpw+AORh4xLOJbZq2BVIEpHbZyM4BEH9g9beLhGQ90F8J0gsmQaSAj1kN4LG9zNE2VcBSYMg7HHc+eJM0LoKSJMR0W2qrXf7N+UecAkDgJcyIDMb+JC8bY8A48/GJnYA7IhNFTYlTBIKI4Lxe4Bx1OuSUwfVAvAq2LGpTLSjpEcZyL6zBpxcBa7hBRRRPUw7d0EXu3sB8lYwYiZX2Ih0p3jFsRd3zBcIkuA2+g2qAY9QBXQhEcWLLOPXIOqNPcEgXtswSVB5IbgdQODCWMcEE3q8bfZEBVAbqjmWUagjJ2v0Vwbe2SuAfZ8v1gg8nCUdMzHG8ELvREGugYg9vJBPmRnxKh8aMcN0kfZPWPDXDL1KiR1q1s5dR3dwcDBz1+FnRJR9TJbfDTRnTz0lAqL9W+uYLOcYJ3dgNRGCiT06xBvzMa4n2T1vGJ7d9KBSsicfqbR4/YrLUfHfyXKfyaLnfzrfDmQ57/r5ZLl2spweQbpfWQ6MRKAJAPQZhfR0kIIlcQSHJx7vOkSwM6wKH2YUFpabqKC6NrHr+dUL75zC67wY65LjVkxE/q2hDfP5sSwA+L9q1IVv5LfGBXf+gCjfdPSAb+xCwc7ww/tMfRRUw/Xp5+bfx45s14BZJM/mH+L2vQGw4J7e25BHdIhvyiNwLo+QQRrIAbAK5rG8eAE2FkdXDt9VYYyRgXGkLJb/LxRQxnLtA1ABx7Ht7Fa40pQ5w7btFmZDpx9n0b9nwwbIBWARQKJgxTF2cUVY/q1ffD6cWLHi08LqaL7gYPUZX3RRObX/eJ/DtP+k5Qj2+OYFIuGRWydZq9m7C1ZW3H+2KJ8iEiGz5hbHr7o2S24Vbwf79rZ1jAr0GZ6m3dj0WVJdbddmgdrx6pXoMBKRYaUeF/h2b9WT1MBtD+5PLJsddTr/kcLa7MQzEeL++hL56mBt/RsRfqkxfL6R3QWWdpfvE6XP7uzdnJu5dWCztE5ZwPk66tEhqS5iDx7K9/Nx+v2DHD6hULnz4OOrT0RNI5k9nk6ftVMHvdrSz6+uLjH8Zk8uXQBnJTVPGYwUy41xGNbj5I8/yrvDWz3q4Y/yiLQzmqM3RdHk9u2XVqsKGNzacBv3pKxFGo02d1Nrv8a13qfU+mZznY3T/r2AoWuUxo2Zc8mXIz2e8W1CjFcKHsnlE0mM9tQMYnLsyUKnZxIYzzz7vPrnO/gfk95sXjqZvjTpNd/TLiR/yGvuNbO5h8m2SWaIbg0lZvTZ8sK2EX5/9nQ01hcmvj9T6NmeTm2b5MZbDiXWdVVGN1eU9FpXHmPwD2Ni9vC9sWTgxvrMnrxZXllkNLfPldw9wGu8cjE/LFiNTdkx7MXTuYO1d1zCPcK67ZE+QRLRaSPEV64UxXCn3pU3N4lXj7+g1jcMBLc8WwgI3HF/sSzm2F39UOBzv9zaNm/pJ2+MXLO1gvbVPLnOm2jtJ6/3gsPfnkfE+k7vXmsdYXK3jFi3PH3QI3tWqC+sTx6rtm1UGdtGhTJwctFmU3QG/yXM6dnSrPsHV3OVbh/c+uTKSdGy7c3qhLb3bnOKFU9+LvW9eLLghxQSE//hWfJl20mSHlXPrQRrn6aNHRq/v3nIvnPbZKJ5LnloMbMueRifsNVMvXGrLJA8UNe7c9vY7R3nUoY9U92zOdmMpZP0W2Z4bk26iI+T6mLl3qrytDRrfbRYFNPeVh3E7r68PXLfcjWDkScHU6drnnpJuV63W9d+Zbd6+b18xLG78ZtHhgOEgdri5VzpbQ7/nVcnpI/eB1Lq8sK80HV8TGP32Bb7w3NHiOTxe2t3lO4KJVY3fRR35IYoXpuxKS/1eGNlwMUT0rSIwSs7IppSk4eaG2K0lkD2c/+zzwqjpkaNO2vHhbVDvhLxj41Y/Qwx5Dv7Yq5Wt9l7W0vM25oKVsptFcXsVr/Mnj6h/I4YObnfR+JvcmrTMpTbB9gDjYU7ezoS7t+QFXP7/f3YI2LxeMnUKQVvGx8vE3eWUjXpZ54/vzSIX6XrT1qXs21JQ+U2uuQoP1JnrrPWVZcYA+S2Ztm+BF+32bQBK1l+J++tLG2H8T1bZlPfv+XefXnBvqsxyc5JhJ5Nlcru9NDg8a18UWDw7pjizpjw63uUdxPkKRmZqfKWJnOmLjxCW6U/MQx+eRq5Y8+LgoTdvsnJNXXvmloM49u2mQO3iDEJd16VN2YqbauO99JH1Vf08LdcWiQbTx6tDuPFVdZG7dvkUm1n11jDMJ4a+pD12NFvHrzCVnzTFzaxKuHFH6XVCg2+Fy8cWijsWHGfCN0jfLqpq1JujNxgc1lVaUttUXVpSwtz7pXIXdddjk5nzSPTQ/oJRfZj4/hN3rknt64/J6JXp9Tm6eRr1Sb8GtRVx9q3NV8qIvBkD+9+1+/z9eiuutZN9PuPFWfyJnFxWzZzcVHXpcj1cUxWR9PcmKEgMD9HF1MwV5yrm9rWOIXdVtSdYPjI9r8tjbLc12+dP5bXmdQdDUlLaOrMsLaN4bvfnh3bPdTc2eWxs+bwQVlH3XhbRuLGYw1F1V2jtVWlHe1JbZ3jrc2JjQfH9nZVpHc0lIZ+dJYBIeJkFD9p03hO8dMIUQNjnQ1NHd1NVUdaCxrGp1qrhxqPNLV19IxMDh9pzq4ZbKrOOjRdUdbclHbwQMmzF6+vHiuoaRqwdvkMaYeNvYZR66Bx0jRqHLPO2nJ1dYV/7TQgY6ex3dRibjN2Gtts4/ZFx4pjxY5/AYWBVSA=') format('woff2');
  font-weight:normal;
  font-style:normal;
  font-display:block;
}

/* Card Editor */
.editingText { background-color: var(--edit-highlight); }

/* Loading animation */
.loading {
  display: inline-block;
  position: relative;
  width: 80px;
  height: 30px;
  text-align: center;
}
.loading:after {
  content: " ";
  display: block;
  border-radius: 50%;
  width: 0;
  height: 0;
  margin: 8px;
  box-sizing: border-box;
  border: 12px solid var(--loading-spinner);
  border-color: var(--loading-spinner) transparent var(--loading-spinner) transparent;
  animation: loading 1.2s infinite;
}
@keyframes loading {
  0% { transform: rotate(0); opacity: 0.8; }
  100% { transform: rotate(360deg); opacity: 0.2; }
}

/* Toast notification */
.toast {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--toast-bg);
  color: var(--toast-text);
  padding: 10px 20px;
  border-radius: 8px;
  box-shadow: var(--shadow-lg);
  z-index: 1000;
  opacity: 0;
  transition: opacity 0.3s ease;
}
.toast.show {
  opacity: 1;
}

/* Modals */
.modalBG {
  display:none;
  position:fixed;
  inset:0;
  background:var(--modal-backdrop);
  z-index:10;
  align-items:center;
  justify-content:center;
  backdrop-filter: blur(2px);
}
.modal {
  width:min(680px, 92vw);
  background:var(--card);
  border-radius:12px;
  border:1px solid var(--line);
  box-shadow:0 18px 60px rgba(12,18,36,0.2);
  padding:20px;
  transform: translateY(20px);
  opacity: 0;
  transition: all 0.2s ease-out;
}
.modalBG.active .modal {
  transform: translateY(0);
  opacity: 1;
}
.modal h3 {
  margin:4px 0 16px;
  color:var(--ink);
  font-size: 1.25em;
}
.grid { 
  display:grid; 
  grid-template-columns: 1fr 1fr; 
  gap:14px; 
}
.grid label {
  font-size:.9em;
  color:var(--ink);
  font-weight:700;
  margin-bottom: 4px;
  display: block;
}
.grid input, .grid textarea {
  width:100%;
  padding:10px 12px;
  border-radius:8px;
  border:1px solid var(--line);
  background:var(--panel);
  color:var(--ink);
  transition: var(--transition);
}
.grid input:focus, .grid textarea:focus {
  border-color: var(--accent);
  outline: none;
  box-shadow: 0 0 0 3px rgba(66, 103, 217, 0.1);
}
.grid textarea { 
  min-height:80px; 
  resize:vertical; 
}
.modalFoot { 
  margin-top:20px; 
  display:flex; 
  justify-content:flex-end; 
  gap:10px; 
}
.onecol { grid-template-columns: 1fr; }
.muted { color:var(--muted); }

/* Empty states */
.empty {
  color:var(--muted);
  text-align:center;
  padding:40px 20px;
  background: var(--panel);
  border-radius: 12px;
  border: 1px dashed var(--line);
  margin: 20px;
}
.empty-icon {
  font-size: 2em;
  margin-bottom: 10px;
  opacity: 0.5;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  background: var(--panel);
}
::-webkit-scrollbar-thumb {
  background: var(--line);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: var(--muted);
}

/* Responsive adjustments */
@media (max-width: 1000px) {
  #main {
    grid-template-columns: 1fr;
  }
  #previewPane {
    display: none;
  }
}

/* Theme Toggle Button */
.theme-toggle {
  position: fixed;
  bottom: 24px;
  right: 24px;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background: var(--card);
  border: 2px solid var(--line);
  box-shadow: var(--shadow-md);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.2s ease, box-shadow 0.3s ease, background 0.3s ease, border-color 0.3s ease;
  z-index: 999;
  backdrop-filter: blur(6px);
}

.theme-toggle:hover {
  transform: translateY(-2px) scale(1.03);
  box-shadow: var(--shadow-md);
  border-color: var(--accent);
  background: var(--panel);
}

.theme-toggle:active {
  transform: translateY(-2px) scale(1.02);
}

.theme-icon {
  transition: transform 0.3s ease, opacity 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
}

.theme-icon svg {
  width: 24px;
  height: 24px;
  stroke: var(--accent);
  transition: stroke 0.3s ease;
}

.theme-toggle:hover .theme-icon svg {
  stroke: var(--accent-hover);
}

/* Sun icon for dark mode (default) */
.theme-icon.sun {
  opacity: 1;
  transform: rotate(0deg) scale(1);
}

/* Moon icon for dark mode (default) - hidden */
.theme-icon.moon {
  opacity: 0;
  transform: rotate(180deg) scale(0.5);
  position: absolute;
}

/* When in light mode, show moon and hide sun */
:root[data-theme="light"] .theme-icon.moon {
  opacity: 1;
  transform: rotate(0deg) scale(1);
  position: relative;
}

:root[data-theme="light"] .theme-icon.sun {
  opacity: 0;
  transform: rotate(-180deg) scale(0.5);
  position: absolute;
}

/* Mobile positioning */
@media (max-width: 700px) {
  .theme-toggle {
    bottom: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
  }

  .theme-icon svg {
    width: 20px;
    height: 20px;
  }
}

/* Menu Bar */
.menu-bar {
  background: var(--card);
  border-bottom: 1px solid var(--line);
  display: flex;
  align-items: center;
  height: 40px;
  padding: 0 10px;
  box-shadow: var(--shadow-sm);
  z-index: 10;
  position: sticky;
  top: 0;
}

.menu-item {
  position: relative;
  padding: 8px 14px;
  cursor: pointer;
  color: var(--ink);
  font-weight: 600;
  font-size: 0.9em;
  border-radius: 6px;
  transition: var(--transition);
}

.menu-item:hover {
  background: var(--panel);
}

.menu-item.active {
  background: var(--accent);
  color: var(--accent-text);
}

.menu-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 8px;
  box-shadow: var(--shadow-md);
  min-width: 200px;
  margin-top: 4px;
  z-index: 1000;
  overflow: hidden;
}

.menu-item.active .menu-dropdown {
  display: block;
}

.menu-dropdown-item {
  padding: 10px 16px;
  cursor: pointer;
  color: var(--ink);
  display: flex;
  align-items: center;
  justify-content: space-between;
  transition: var(--transition);
  border-bottom: 1px solid var(--line);
}

.menu-dropdown-item:last-child {
  border-bottom: none;
}

.menu-dropdown-item:hover {
  background: var(--panel);
}

.menu-dropdown-item .shortcut {
  color: var(--muted);
  font-size: 0.85em;
  margin-left: 20px;
}

.menu-separator {
  height: 1px;
  background: var(--line);
  margin: 4px 0;
}

/* Search Box */
.search-box {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  max-width: 400px;
}

.search-box input {
  flex: 1;
  padding: 6px 12px;
  border-radius: 6px;
  border: 1px solid var(--line);
  background: var(--panel);
  color: var(--ink);
  font-size: 0.9em;
  transition: var(--transition);
}

.search-box input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(66, 103, 217, 0.1);
}

.search-box button {
  padding: 6px 10px;
  font-size: 0.85em;
}

/* Bulk Selection */
.bulk-actions {
  display: none;
  gap: 8px;
  padding: 8px 16px;
  background: var(--accent);
  color: var(--accent-text);
  align-items: center;
  border-bottom: 1px solid var(--line);
}

.bulk-actions.active {
  display: flex;
}

.bulk-actions button {
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  color: var(--accent-text);
  padding: 5px 10px;
  font-size: 0.85em;
}

.bulk-actions button:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Card Selection */
.row-checkbox {
  width: 20px;
  height: 20px;
  cursor: pointer;
  accent-color: var(--accent);
}

.drag-handle {
  cursor: move;
  color: var(--muted);
  font-size: 1.2em;
  padding: 0 8px;
  user-select: none;
}

.drag-handle:hover {
  color: var(--ink);
}

.row.dragging {
  opacity: 0.5;
}

.row.drag-over {
  border-top: 3px solid var(--accent);
}

/* Keyboard Shortcut Indicator */
.shortcut-help {
  position: fixed;
  bottom: 80px;
  right: 24px;
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 8px;
  padding: 12px 16px;
  box-shadow: var(--shadow-md);
  z-index: 998;
  max-width: 300px;
  display: none;
}

.shortcut-help.show {
  display: block;
}

.shortcut-help h4 {
  margin: 0 0 10px 0;
  color: var(--ink);
  font-size: 0.95em;
}

.shortcut-help .shortcut-item {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  font-size: 0.85em;
  color: var(--ink);
}

.shortcut-help .shortcut-item kbd {
  background: var(--panel);
  padding: 2px 6px;
  border-radius: 4px;
  border: 1px solid var(--line);
  font-family: monospace;
  font-size: 0.9em;
}

/* Search Highlighting */
.search-highlight {
  background: var(--accent);
  color: var(--accent-text);
  padding: 2px 4px;
  border-radius: 3px;
}

/* Status Bar */
.status-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 16px;
  background: var(--panel);
  border-top: 1px solid var(--line);
  font-size: 0.85em;
  color: var(--muted);
}

.status-bar-item {
  display: flex;
  align-items: center;
  gap: 6px;
}
</style>
  <script src="theme-toggle.js"></script>
  <!-- Libraries for APKG import with SRI integrity checks -->
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
    integrity="sha512-XMVd28F1oH/O71fzwBnV7HucLxVwtxf26XV8P4wPk26EDxuGZ91N8bsOttmnomcCD3CS5ZMRL50H0GgOHvegtg=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/sql-wasm.js"
    integrity="sha512-EHnJJvBu6FjhcN8S9eGmRUJWzVLz+5B0XU0Hh/aelHs4DCohGCp9+mPPFLj2J6XSZPOmHqIxfCsAEDYqeJdzZA=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"></script>
</head>
<body>

<!-- Menu Bar -->
<div class="menu-bar">
  <div class="menu-item">
    <span>File</span>
    <div class="menu-dropdown">
      <div class="menu-dropdown-item" id="menuImport">
        <span>Import File</span>
        <span class="shortcut">Ctrl+O</span>
      </div>
      <div class="menu-dropdown-item" id="menuExport">
        <span>Export File</span>
        <span class="shortcut">Ctrl+S</span>
      </div>
    </div>
  </div>
  <div class="menu-item">
    <span>Edit</span>
    <div class="menu-dropdown">
      <div class="menu-dropdown-item" id="menuAddCard">
        <span>Add Card</span>
        <span class="shortcut">Ctrl+N</span>
      </div>
      <div class="menu-dropdown-item" id="menuDuplicateCard">
        <span>Duplicate Card</span>
        <span class="shortcut">Ctrl+D</span>
      </div>
      <div class="menu-dropdown-item" id="menuDeleteCard">
        <span>Delete Card</span>
        <span class="shortcut">Delete</span>
      </div>
      <div class="menu-separator"></div>
      <div class="menu-dropdown-item" id="menuSelectAll">
        <span>Select All</span>
        <span class="shortcut">Ctrl+A</span>
      </div>
      <div class="menu-dropdown-item" id="menuDeselectAll">
        <span>Deselect All</span>
        <span class="shortcut">Esc</span>
      </div>
    </div>
  </div>
  <div class="menu-item">
    <span>View</span>
    <div class="menu-dropdown">
      <div class="menu-dropdown-item" id="menuToggleTheme">
        <span>Toggle Theme</span>
        <span class="shortcut">Ctrl+T</span>
      </div>
      <div class="menu-separator"></div>
      <div class="menu-dropdown-item" id="menuSearch">
        <span>Search Cards</span>
        <span class="shortcut">Ctrl+F</span>
      </div>
    </div>
  </div>
  <div class="menu-item">
    <span>Help</span>
    <div class="menu-dropdown">
      <div class="menu-dropdown-item" id="menuShortcuts">
        <span>Keyboard Shortcuts</span>
        <span class="shortcut">?</span>
      </div>
    </div>
  </div>
</div>

<div class="page-wrapper">
<!-- SIDEBAR -->
<aside id="sidebar">
<div id="topbar">
<div class="title">KAnki Editor</div>
<div class="actions">
<input id="fileInput" type="file" accept=".js,.apkg" style="display:none" />
<button class="btn-ghost btn-small" id="btnImport">Import</button>
<button class="btn-primary btn-small" id="btnExport" disabled>Export</button>
</div>
</div>
<div id="deckListWrap">
<div class="deckHeader">Decks / Levels</div>
<ul id="deckList"></ul>
</div>
<div class="deckFoot">
<button id="btnAddDeck" class="btn-ghost">+ Add Deck</button>
</div>
</aside>

<!-- MAIN -->
<main id="main">
<!-- Cards -->
<section id="cardsPane">
<div id="cardsBar">
<div class="levelTitle" id="levelTitle">(no deck selected)</div>
<div class="search-box">
  <input type="text" id="searchInput" placeholder="Search cards..." />
  <button id="btnClearSearch" class="btn-ghost btn-small" style="display:none;">✕</button>
</div>
<div style="margin-left:auto; display:flex; gap:8px;">
<button id="btnAddCard" class="btn-ghost btn-small" disabled>+ Add Card</button>
</div>
</div>
<div class="bulk-actions" id="bulkActions">
  <span id="bulkCount">0 selected</span>
  <button id="btnBulkDuplicate">Duplicate</button>
  <button id="btnBulkDelete">Delete</button>
  <button id="btnDeselectAll">Deselect All</button>
</div>
<div id="cardsList"></div>
<div id="cardsFoot">
  <div class="status-bar">
    <div class="status-bar-item">
      <span id="statusCount">0 cards</span>
    </div>
    <div class="status-bar-item">
      <span id="statusFilter"></span>
    </div>
  </div>
</div>
</section>

<!-- Preview -->
<aside id="previewPane">
<div id="previewBar">
<div class="muted">Live Preview</div>
<div>
<label class="muted" for="deviceSel">Kindle size:</label>
<select id="deviceSel">
<option value="340,480">Basic (340×480)</option>
<option value="360,540" selected>Paperwhite 3/4 (360×540)</option>
<option value="412,600">PW5 / Oasis (412×600)</option>
<option value="514,660">Oasis 3 / Signature (514×660)</option>
<option value="640,900">Scribe-ish (640×900)</option>
</select>
</div>
</div>
<div id="previewHost">
<div id="device" style="width:360px; height:540px;">
<!-- KAnki App HTML Structure -->
<div id="headerBar">
  <div class="topBar">
    <div class="logoArea">
      <h1 id="title">KAnki</h1>
    </div>
    <div class="infoArea">
      <div id="progressDisplay" class="progressBar">Cards: 0/0 (0%)</div>
      <div id="levelDisplay" class="levelDisplay">Current Deck: None</div>
    </div>
  </div>
  <div class="menuBar">
    <div id="levelButtons" class="menuSection">
      <button class="active">All Levels</button>
    </div>
    <div class="menuDivider"></div>
    <div id="toolButtons" class="menuSection">
      <button id="starredFilterBtn">★ Star</button>
      <button id="reverseToggleBtn">↔ Flip</button>
    </div>
  </div>
</div>

<div id="mainContainer">
  <div id="cardContainer" class="card">
    <div id="levelBadge" class="levelBadge">Deck</div>
    <button id="starButton" class="starButton">☆</button>
    <div id="cardFront" class="cardFront">Import a file to start</div>
    <div id="cardBack" class="cardBack"></div>
    <div id="cardNotes" class="cardNotes"></div>
    <div id="cardStats" class="cardStats"></div>
  </div>

  <div id="controlButtons" class="buttonContainer">
    <button id="showAnswerBtn">Show Answer</button>
    <div id="intervalButtons" style="display: none;">
      <button class="intervalBtn againBtn">Again<br>&lt;10m</button>
      <button class="intervalBtn hardBtn">Hard<br>1d</button>
      <button class="intervalBtn goodBtn">Good<br>3d</button>
      <button class="intervalBtn easyBtn">Easy<br>7d</button>
    </div>
  </div>
</div>

<div class="footer">
  <p>v1.1.0</p>
</div>
</div>
</div>
</aside>
</main>
</div>

<!-- CARD MODAL -->
<div id="cardModalBG" class="modalBG">
<div class="modal">
<h3 id="cardModalTitle">Add/Edit Card</h3>
<div id="cardFields" class="grid"></div>
<div class="modalFoot">
<button id="btnCancelCard" class="btn-ghost">Cancel</button>
<button id="btnSaveCard" class="btn-primary">Save</button>
</div>
</div>
</div>

<!-- DECK MODAL -->
<div id="deckModalBG" class="modalBG">
<div class="modal">
<h3>Add Deck/Level</h3>
<div class="grid onecol">
<label for="deckName">Deck/Level name</label>
<input id="deckName" placeholder="e.g., AirspeedSymbols" />
</div>
<div class="modalFoot">
<button id="btnCancelDeck" class="btn-ghost">Cancel</button>
<button id="btnSaveDeck" class="btn-primary">Add</button>
</div>
</div>
</div>

<!-- Toast notification -->
<div id="toast" class="toast"></div>

<!-- Theme Toggle Button -->
<button class="theme-toggle" aria-label="Toggle light/dark mode">
  <span class="theme-icon sun">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </span>
  <span class="theme-icon moon">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </span>
</button>

<!-- Keyboard Shortcuts Help -->
<div class="shortcut-help" id="shortcutHelp">
  <h4>Keyboard Shortcuts</h4>
  <div class="shortcut-item">
    <span>New Card</span>
    <kbd>Ctrl+N</kbd>
  </div>
  <div class="shortcut-item">
    <span>Duplicate Card</span>
    <kbd>Ctrl+D</kbd>
  </div>
  <div class="shortcut-item">
    <span>Delete Card</span>
    <kbd>Delete</kbd>
  </div>
  <div class="shortcut-item">
    <span>Search</span>
    <kbd>Ctrl+F</kbd>
  </div>
  <div class="shortcut-item">
    <span>Select All</span>
    <kbd>Ctrl+A</kbd>
  </div>
  <div class="shortcut-item">
    <span>Navigate</span>
    <kbd>↑ ↓</kbd>
  </div>
  <div class="shortcut-item">
    <span>Save/Export</span>
    <kbd>Ctrl+S</kbd>
  </div>
  <div class="shortcut-item">
    <span>Close/Escape</span>
    <kbd>Esc</kbd>
  </div>
</div>

<script>
/* ===== State ===== */
let allDecks = {}; // { level: [ {front, back, ...}, ... ] }
let levels = []; // [levelName, ...]
let selectedLevel = '';
let selectedCardIndex = -1;
let customFields = new Set(['front','back','notes','reading']);
let importedFileName = 'kanki_config.js';
let importedLanguage = 'Deck';
let editingDraft = null; // holds draft data while editing (for live preview)
let isEditExisting = false;
let lastVisibleCardIdx = -1; // Track last visible card for scroll sync
let hasInitialized = false;

// New state for search and bulk operations
let searchQuery = '';
let selectedCards = new Set(); // indices of selected cards
let draggedCardIndex = -1;

/* ===== Dom helpers ===== */
const $ = sel => document.querySelector(sel);
const $$ = sel => document.querySelectorAll(sel);
function el(tag, props={}, children=[]) {
  const n = document.createElement(tag);
  Object.assign(n, props);
  for (const c of (Array.isArray(children)?children:[children])) {
    if (typeof c === 'string') n.appendChild(document.createTextNode(c));
    else if (c) n.appendChild(c);
  }
  return n;
}
function escapeHTML(txt='') {
  return String(txt).replace(/[<>&"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;'}[c]));
}

/* ===== Search Highlighting ===== */
function highlightText(text, query) {
  if (!query || !text) return escapeHTML(text);
  const escapedText = escapeHTML(text);
  const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
  return escapedText.replace(regex, '<span class="search-highlight">$1</span>');
}

function matchesSearch(card, query) {
  if (!query) return true;
  const q = query.toLowerCase();
  return (
    (card.front || '').toLowerCase().includes(q) ||
    (card.back || '').toLowerCase().includes(q) ||
    (card.notes || '').toLowerCase().includes(q) ||
    (card.reading || '').toLowerCase().includes(q)
  );
}

/* ===== Toast Notification ===== */
function showToast(message, duration = 3000) {
  const toast = $('#toast');
  toast.textContent = message;
  toast.classList.add('show');
  
  setTimeout(() => {
    toast.classList.remove('show');
  }, duration);
}

/* ===== Modal Controls ===== */
function openModal(id) {
  const modal = $(`#${id}`);
  modal.style.display = 'flex';
  
  // Trigger animation after display is set
  setTimeout(() => {
    modal.classList.add('active');
  }, 10);
}

function closeModal(id) {
  const modal = $(`#${id}`);
  modal.classList.remove('active');
  
  // Wait for animation to complete before hiding
  setTimeout(() => {
    modal.style.display = 'none';
  }, 200);
}

/* ===== Import / Parse ===== */
// CRITICAL FIX: Import lock to prevent race conditions
let _isImporting = false;
const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB limit

$('#btnImport').addEventListener('click', ()=> $('#fileInput').click());
$('#fileInput').addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if (!f) return;

  // FIX #1: Race condition protection
  if (_isImporting) {
    showToast('Import already in progress. Please wait...', 3000);
    e.target.value = '';
    return;
  }

  // FIX #5: Resource exhaustion protection
  if (f.size > MAX_FILE_SIZE) {
    showToast(`File too large (${(f.size/1024/1024).toFixed(1)}MB). Maximum size is ${MAX_FILE_SIZE/1024/1024}MB.`, 5000);
    alert(`File is too large: ${(f.size/1024/1024).toFixed(1)}MB\n\nMaximum supported size: ${MAX_FILE_SIZE/1024/1024}MB\n\nPlease use a smaller deck or split it into multiple files.`);
    e.target.value = '';
    return;
  }

  try {
    _isImporting = true;

    // Detect file type
    const fileName = f.name.toLowerCase();
    if (fileName.endsWith('.apkg')) {
      // Check browser support before attempting APKG import
      if (!checkAPKGSupport()) {
        showToast('APKG import not supported in this browser. Please use .js files instead.', 7000);
        alert('Your browser does not support APKG import.\n\nRequired features:\n- File API (arrayBuffer)\n- WebAssembly\n- JSZip library\n- sql.js library\n\nPlease use a modern browser (Chrome 85+, Firefox 78+, Safari 14+, Edge 85+) or export your Anki deck as text.');
        return;
      }
      await importAPKG(f);
    } else {
      importKAnkiJS(f);
    }
  } catch (err) {
    console.error('Import error:', err);
    showToast('Import failed: ' + err.message, 5000);
  } finally {
    // FIX #15: Only reset input after import completes (success or fail)
    _isImporting = false;
    e.target.value = '';
  }
});

// Check if browser supports APKG import features
// FIX #24: Comprehensive feature detection
function checkAPKGSupport() {
  // Check FileReader exists
  if (typeof FileReader === 'undefined') {
    console.warn('FileReader not supported');
    return false;
  }

  // Check Promise support
  if (typeof Promise === 'undefined') {
    console.warn('Promise not supported');
    return false;
  }

  // Check File API arrayBuffer support
  if (!File.prototype.arrayBuffer) {
    console.warn('File.arrayBuffer() not supported');
    return false;
  }

  // Check if JSZip library loaded
  if (typeof JSZip === 'undefined') {
    console.warn('JSZip library not loaded');
    return false;
  }

  // Check if sql.js loaded
  if (typeof initSqlJs === 'undefined') {
    console.warn('sql.js library not loaded');
    return false;
  }

  // Check WebAssembly support (required by sql.js)
  if (typeof WebAssembly === 'undefined') {
    console.warn('WebAssembly not supported');
    return false;
  }

  // Check DOMParser for secure HTML stripping
  if (typeof DOMParser === 'undefined') {
    console.warn('DOMParser not supported');
    return false;
  }

  return true;
}

// Import KAnki .js format (original functionality)
function importKAnkiJS(f) {
  importedFileName = f.name || 'kanki_config.js';
  const reader = new FileReader();
  reader.onload = ev => {
    try {
      const jsText = String(ev.target.result || '');
      // Create a sandboxed function scope for var declarations from file
      const fn = new Function(
        jsText + '\nreturn {KANKI_CONFIG: (typeof KANKI_CONFIG!=="undefined"?KANKI_CONFIG:null), VOCABULARY: (typeof VOCABULARY!=="undefined"?VOCABULARY:null)};'
      );
      const parsed = fn();
      if (!parsed || !parsed.VOCABULARY || typeof parsed.VOCABULARY !== 'object') {
        throw new Error('Could not find a valid VOCABULARY object.');
      }
      allDecks = {};
      levels = [];
      customFields = new Set(['front','back','notes','reading']);
      importedLanguage = (parsed.KANKI_CONFIG && parsed.KANKI_CONFIG.language) ? parsed.KANKI_CONFIG.language : 'Deck';
      for (const key of Object.keys(parsed.VOCABULARY)) {
        const list = Array.isArray(parsed.VOCABULARY[key]) ? parsed.VOCABULARY[key] : [];
        allDecks[key] = list.map(c => ({...c}));
        levels.push(key);
        list.forEach(card => Object.keys(card||{}).forEach(f=>customFields.add(f)));
      }
      if (levels.length === 0) {
        selectedLevel = ''; selectedCardIndex = -1;
      } else {
        selectedLevel = levels[0]; selectedCardIndex = 0;
      }
      editingDraft = null;
      isEditExisting = false;
      renderAll();
      $('#btnExport').disabled = false;
      $('#btnAddCard').disabled = !selectedLevel;
      showToast("File imported successfully!");
    } catch (err) {
      showToast("Error: Could not parse file", 5000);
      alert('Could not parse kanki_config.js:\n' + err.message);
    }
  };
  reader.readAsText(f);
}

// Import Anki .apkg format - COMPLETELY REBUILT WITH ALL FIXES
async function importAPKG(f) {
  let db = null;
  let arrayBuffer = null;
  let zip = null;

  // FIX #6: Build state locally, only update globals on success
  const localState = {
    allDecks: {},
    levels: [],
    customFields: new Set(['front','back','notes']),
    importedLanguage: 'Anki Import',
    importedFileName: f.name.replace('.apkg', '.js') || 'kanki_config.js'
  };

  try {
    showToast("Importing Anki deck... (0%)", 1000);

    // FIX #23: Add timeout wrapper for all async operations
    const withTimeout = (promise, ms, errorMsg) => {
      return Promise.race([
        promise,
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error(errorMsg)), ms)
        )
      ]);
    };

    // Step 1: Unzip the APKG file (with timeout)
    arrayBuffer = await withTimeout(
      f.arrayBuffer(),
      30000,
      'File reading timed out after 30 seconds'
    );

    showToast("Importing Anki deck... (20%)", 1000);

    zip = await withTimeout(
      JSZip.loadAsync(arrayBuffer),
      30000,
      'ZIP extraction timed out after 30 seconds'
    );

    // FIX #9: Clear arrayBuffer reference to allow GC
    arrayBuffer = null;

    showToast("Importing Anki deck... (40%)", 1000);

    // Step 2: Find and extract the SQLite database
    let dbFile;
    if (zip.file('collection.anki21')) {
      dbFile = await zip.file('collection.anki21').async('arraybuffer');
    } else if (zip.file('collection.anki2')) {
      dbFile = await zip.file('collection.anki2').async('arraybuffer');
    } else {
      throw new Error('No Anki database found in APKG file. This may not be a valid Anki deck.');
    }

    // FIX #9: Clear zip reference
    zip = null;

    showToast("Importing Anki deck... (60%)", 1000);

    // Step 3: Initialize SQL.js and load the database (with timeout)
    // FIX #14: Better error handling for WASM load
    let SQL;
    try {
      SQL = await withTimeout(
        initSqlJs({
          locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/${file}`
        }),
        60000,
        'SQLite library initialization timed out. Check internet connection.'
      );
    } catch (err) {
      throw new Error('Failed to load SQLite library. This may be due to a network issue or CDN being blocked. Error: ' + err.message);
    }

    if (!SQL) {
      throw new Error('Failed to initialize SQLite library');
    }

    db = new SQL.Database(new Uint8Array(dbFile));

    // FIX #9: Clear dbFile reference
    dbFile = null;

    showToast("Importing Anki deck... (70%)", 1000);

    // Step 4: Extract decks and notes with robust error handling
    // FIX #10: Track deck names to handle duplicates
    const decksMap = {};
    const deckNameCounts = {};

    try {
      // FIX #18: Validate SQL result structure
      const decksResult = db.exec('SELECT id, name FROM decks');
      if (decksResult && decksResult.length > 0 && Array.isArray(decksResult[0].values)) {
        decksResult[0].values.forEach(([id, name]) => {
          try {
            // FIX #20: Ensure deckId is string
            const deckIdStr = String(id);

            // FIX #12: Validate type before parsing
            if (name && typeof name === 'string') {
              const deckData = JSON.parse(name);

              // FIX #12: Check name is actually a string
              if (deckData && typeof deckData.name === 'string' && deckData.name.trim()) {
                let deckName = deckData.name.trim();

                // FIX #10: Handle duplicate deck names
                if (deckNameCounts[deckName]) {
                  deckNameCounts[deckName]++;
                  deckName = `${deckName} (${deckNameCounts[deckName]})`;
                } else {
                  deckNameCounts[deckName] = 1;
                }

                decksMap[deckIdStr] = deckName;
              } else {
                decksMap[deckIdStr] = 'Default';
              }
            } else {
              decksMap[deckIdStr] = 'Default';
            }
          } catch (parseErr) {
            console.warn('Failed to parse deck name:', name, parseErr);
            decksMap[String(id)] = `Deck ${id}`;
          }
        });
      }
    } catch (sqlErr) {
      console.warn('Could not read decks table:', sqlErr);
      // Continue anyway, will use 'Default' for all cards
    }

    showToast("Importing Anki deck... (80%)", 1000);

    // Get cards and notes
    let notesResult;
    try {
      // FIX #18: Validate query result
      notesResult = db.exec(`
        SELECT DISTINCT n.flds, n.mid, c.did
        FROM notes n
        JOIN cards c ON c.nid = n.id
        ORDER BY c.did
      `);

      if (!notesResult || !Array.isArray(notesResult) || notesResult.length === 0) {
        throw new Error('No results from cards query');
      }

      if (!Array.isArray(notesResult[0].values) || notesResult[0].values.length === 0) {
        throw new Error('No cards found in APKG file. The deck may be empty.');
      }
    } catch (sqlErr) {
      throw new Error('Failed to read cards from database. The APKG file may be corrupted. ' + sqlErr.message);
    }

    showToast("Importing Anki deck... (90%)", 1000);

    // FIX #8: Reuse single HTML stripper instance
    const htmlStripper = createHTMLStripper();

    // Step 5: Convert to KAnki format
    let cardsProcessed = 0;
    const totalToProcess = notesResult[0].values.length;

    notesResult[0].values.forEach(([fields, modelId, deckId]) => {
      try {
        // FIX #19: Ensure fields is a string
        const fieldsStr = (fields != null && typeof fields === 'string') ? fields : String(fields || '');

        // FIX #11: Unicode separator handling - validate split didn't fail
        const fieldArray = fieldsStr.split('\x1f');

        // FIX #20: Ensure deckId is proper key type
        const deckIdStr = String(deckId);
        const deckName = decksMap[deckIdStr] || 'Default';

        // Initialize deck if needed
        if (!localState.allDecks[deckName]) {
          localState.allDecks[deckName] = [];
          localState.levels.push(deckName);
        }

        // Convert to KAnki card format
        const card = {
          front: htmlStripper.strip(fieldArray[0] || ''),
          back: htmlStripper.strip(fieldArray[1] || ''),
          notes: ''
        };

        // FIX #19: Type-safe filter - validate strings
        if (fieldArray.length > 2) {
          const extraFields = fieldArray.slice(2)
            .filter(f => f != null && typeof f === 'string' && f.trim())
            .map(f => htmlStripper.strip(f));

          if (extraFields.length > 0) {
            card.notes = extraFields.join(' | ');
          }
        }

        localState.allDecks[deckName].push(card);
        cardsProcessed++;

      } catch (cardErr) {
        console.warn('Failed to parse card, skipping:', cardErr);
        // Skip this card and continue
      }
    });

    // FIX #8: Cleanup HTML stripper
    htmlStripper.cleanup();

    // FIX #21: Verify we got cards with sanity check
    const totalCards = Object.values(localState.allDecks).reduce((sum, deck) => sum + deck.length, 0);

    if (totalCards === 0) {
      throw new Error('No valid cards could be imported from the APKG file.');
    }

    if (totalCards > 1000000) {
      console.warn('Suspiciously large number of cards:', totalCards);
    }

    // Step 6: FIX #6 - Only update global state on complete success
    allDecks = localState.allDecks;
    levels = localState.levels;
    customFields = localState.customFields;
    importedLanguage = localState.importedLanguage;
    importedFileName = localState.importedFileName;

    if (levels.length === 0) {
      selectedLevel = '';
      selectedCardIndex = -1;
    } else {
      selectedLevel = levels[0];
      selectedCardIndex = 0;
    }

    editingDraft = null;
    isEditExisting = false;
    renderAll();
    $('#btnExport').disabled = false;
    $('#btnAddCard').disabled = !selectedLevel;

    // FIX #22: Consistent error handling - use toast only
    showToast(`✓ Anki deck imported! ${totalCards} cards in ${levels.length} deck(s)`, 5000);

  } catch (err) {
    console.error('APKG import error:', err);

    // FIX #22: Consistent error messaging
    let userMessage = 'Import failed: ' + err.message;

    if (err.message.includes('not a valid zip')) {
      userMessage += '\n\nThe file may be corrupted. Try re-downloading it.';
    } else if (err.message.includes('No Anki database')) {
      userMessage += '\n\nThis may not be a valid Anki deck file.';
    } else if (err.message.includes('timed out')) {
      userMessage += '\n\nThe file may be too large or your connection is slow.';
    }

    showToast(userMessage, 7000);
    alert(userMessage);

    // Re-throw to propagate to outer error handler
    throw err;

  } finally {
    // Clean up all resources
    if (db) {
      try {
        db.close();
      } catch (closeErr) {
        console.warn('Error closing database:', closeErr);
      }
    }

    // FIX #9: Force cleanup of large objects
    db = null;
    arrayBuffer = null;
    zip = null;
  }
}

// FIX #3, #7, #8, #16, #17, #24, #25: Secure, efficient HTML stripper
// Creates reusable stripper instance to avoid memory leaks
function createHTMLStripper() {
  // FIX #25: Use IIFE to avoid global pollution (no longer global)
  // FIX #8 & #16: Single reusable parser instance
  let parser = null;
  let lastDoc = null;

  // Initialize parser once
  if (typeof DOMParser !== 'undefined') {
    parser = new DOMParser();
  }

  return {
    strip: function(html) {
      if (!html || typeof html !== 'string') {
        return '';
      }

      // Trim to prevent processing huge strings
      if (html.length > 100000) {
        console.warn('HTML field too long, truncating');
        html = html.substring(0, 100000) + '...';
      }

      try {
        // FIX #3: ONLY use DOMParser (no innerHTML - prevents XSS)
        if (parser) {
          // FIX #8: Reuse parser, but get fresh document each time
          const doc = parser.parseFromString(html, 'text/html');
          const text = doc.body.textContent || '';

          // FIX #24: Clear reference to allow GC
          lastDoc = null;

          return text;
        } else {
          // FIX #17: Safe regex with non-greedy match to prevent catastrophic backtracking
          // Limit iterations and use simpler pattern
          return String(html)
            .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // Remove scripts first
            .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '')   // Remove styles
            .replace(/<[^>]{1,1000}>/g, ''); // Remove tags (limit to 1000 chars per tag)
        }
      } catch (err) {
        console.warn('Error stripping HTML, using safe fallback:', err);
        // Safe fallback - just remove anything that looks like a tag
        return String(html).replace(/<[^>]{1,1000}>/g, '');
      }
    },

    cleanup: function() {
      // FIX #8 & #24: Explicit cleanup
      parser = null;
      lastDoc = null;
    }
  };
}

// Legacy function for backward compatibility (uses secure method)
function stripHTML(html) {
  const stripper = createHTMLStripper();
  const result = stripper.strip(html);
  stripper.cleanup();
  return result;
}

/* ===== Export ===== */
$('#btnExport').addEventListener('click', ()=>{
  if (!levels.length) {
    showToast('Nothing to export. Import a file first.'); 
    return;
  }
  const safeLanguage = importedLanguage || 'Deck';
  const config = `var KANKI_CONFIG = {
  language: ${JSON.stringify(safeLanguage)},
  levels: [${levels.map(l=>JSON.stringify(l)).join(', ')}]
};`;

  const vocab = 'var VOCABULARY = {\n' + levels.map(level => {
    const cards = (allDecks[level] || []).map(c => JSON.stringify(c)).join(',\n  ');
    return `  ${JSON.stringify(level)}: [\n  ${cards}\n  ]`;
  }).join(',\n') + '\n};\n';

  const out = `/**\n * KAnki Configuration (exported)\n */\n${config}\n\n/**\n * Flashcards (exported)\n */\n${vocab}`;
  const blob = new Blob([out], {type: 'application/javascript'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = importedFileName || 'kanki_config.js';
  a.click();
  showToast("File exported successfully!");
});

/* ===== Decks UI ===== */
function renderDecks() {
  const ul = $('#deckList');
  ul.innerHTML = '';
  
  if (!levels.length) {
    ul.appendChild(el('li', { className: 'empty' }, [
      el('div', { className: 'empty-icon' }, '📚'),
      el('div', {}, 'No decks yet. Import a file or add a deck to begin.')
    ]));
    return;
  }
  
  levels.forEach(level => {
    const li = el('li', { className: 'deckItem' + (selectedLevel === level ? ' selected' : '') }, [
      el('span', {}, level),
      el('span', { className:'spacer' }),
      el('button', { className:'del', title:'Delete deck', onclick: (e)=>{ e.stopPropagation(); deleteDeck(level); } }, '✕')
    ]);
    li.addEventListener('click', ()=>{
      selectedLevel = level; selectedCardIndex = 0; editingDraft = null;
      $('#btnAddCard').disabled = false;
      renderAll();
    });
    ul.appendChild(li);
  });
}

$('#btnAddDeck').addEventListener('click', ()=> {
  openModal('deckModalBG');
  $('#deckName').value = '';
  setTimeout(()=> $('#deckName').focus(), 30);
});

$('#btnCancelDeck').addEventListener('click', ()=> closeModal('deckModalBG'));

$('#btnSaveDeck').addEventListener('click', ()=>{
  const name = ($('#deckName').value || '').trim();
  if (!name) return;
  if (levels.includes(name)) { 
    showToast('Deck already exists.'); 
    return; 
  }
  allDecks[name] = [];
  levels.push(name);
  selectedLevel = name;
  selectedCardIndex = -1;
  closeModal('deckModalBG');
  $('#btnAddCard').disabled = false;
  renderAll();
  showToast(`Deck "${name}" created!`);
});

function deleteDeck(level) {
  if (!confirm(`Delete deck "${level}" and all its cards?`)) return;
  levels = levels.filter(l => l !== level);
  delete allDecks[level];
  if (selectedLevel === level) {
    selectedLevel = levels[0] || '';
    selectedCardIndex = selectedLevel ? 0 : -1;
  }
  renderAll();
  showToast(`Deck "${level}" deleted`);
}

/* ===== Cards UI ===== */
$('#btnAddCard').addEventListener('click', ()=> openCardModal(null));

function renderCards() {
  $('#levelTitle').textContent = selectedLevel ? `Deck: ${selectedLevel}` : '(no deck selected)';
  const list = $('#cardsList');
  list.innerHTML = '';

  if (!selectedLevel) {
    list.appendChild(el('div', {className:'empty'}, [
      el('div', { className: 'empty-icon' }, '📝'),
      el('div', {}, 'Import a file or add a deck to begin.')
    ]));
    updateStatusBar();
    return;
  }

  const cards = allDecks[selectedLevel] || [];

  if (!cards.length) {
    list.appendChild(el('div', {className:'empty'}, [
      el('div', { className: 'empty-icon' }, '✨'),
      el('div', {}, 'No cards yet — add your first card.')
    ]));
    updateStatusBar();
    return;
  }

  // Filter cards by search
  const filteredIndices = cards.map((card, i) => ({ card, i }))
    .filter(({card}) => matchesSearch(card, searchQuery));

  if (filteredIndices.length === 0 && searchQuery) {
    list.appendChild(el('div', {className:'empty'}, [
      el('div', { className: 'empty-icon' }, '🔍'),
      el('div', {}, `No cards match "${searchQuery}"`)
    ]));
    updateStatusBar();
    return;
  }

  // Create cards with new features
  filteredIndices.forEach(({card, i}) => {
    const row = el('div', {
      className: 'row' + (i === selectedCardIndex ? ' selected' : ''),
      id: `card-${i}`,
      draggable: true
    });
    row.dataset.index = i;

    // Drag handle
    const dragHandle = el('div', { className: 'drag-handle', title: 'Drag to reorder' }, '⋮⋮');
    dragHandle.addEventListener('mousedown', (e) => e.stopPropagation());

    // Checkbox for bulk selection
    const checkbox = el('input', {
      type: 'checkbox',
      className: 'row-checkbox',
      checked: selectedCards.has(i)
    });
    checkbox.addEventListener('change', (e) => {
      e.stopPropagation();
      if (e.target.checked) {
        selectedCards.add(i);
      } else {
        selectedCards.delete(i);
      }
      updateBulkActions();
    });

    row.addEventListener('click', (e)=>{
      if (e.target.type === 'checkbox') return;
      selectedCardIndex = i;
      editingDraft = null;
      renderPreview();
      highlightSelectedRow();
    });

    // Drag and drop handlers
    row.addEventListener('dragstart', (e) => {
      draggedCardIndex = i;
      row.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    });

    row.addEventListener('dragend', () => {
      row.classList.remove('dragging');
      $$('#cardsList .row').forEach(r => r.classList.remove('drag-over'));
    });

    row.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      const dragging = $('#cardsList .dragging');
      if (dragging && dragging !== row) {
        row.classList.add('drag-over');
      }
    });

    row.addEventListener('dragleave', () => {
      row.classList.remove('drag-over');
    });

    row.addEventListener('drop', (e) => {
      e.preventDefault();
      row.classList.remove('drag-over');
      if (draggedCardIndex !== -1 && draggedCardIndex !== i) {
        reorderCard(draggedCardIndex, i);
      }
    });

    const c1 = el('div', { className:'cell' });
    c1.innerHTML = highlightText(card.front || '', searchQuery);

    const c2 = el('div', { className:'cell' });
    c2.innerHTML = highlightText(card.back || '', searchQuery);

    const c3 = el('div', { className:'cell muted' });
    c3.innerHTML = highlightText(card.notes || card.reading || '', searchQuery);

    const actions = el('div', { className:'actions' }, [
      el('button', { className:'btn-small', onclick:(e)=>{ e.stopPropagation(); openCardModal(i); } }, 'Edit'),
      el('button', { className:'btn-small', onclick:(e)=>{ e.stopPropagation(); duplicateCard(i); } }, 'Dup'),
      el('button', { className:'btn-small btn-danger', onclick:(e)=>{ e.stopPropagation(); deleteCard(i); } }, 'Del')
    ]);

    row.appendChild(dragHandle);
    row.appendChild(checkbox);
    row.appendChild(c1);
    row.appendChild(c2);
    row.appendChild(c3);
    row.appendChild(actions);
    list.appendChild(row);
  });

  // Set up intersection observer to track visible cards
  setupCardVisibilityObserver();
  updateStatusBar();
  updateBulkActions();
}

function setupCardVisibilityObserver() {
  // Remove any existing observer
  if (window.cardObserver) {
    window.cardObserver.disconnect();
  }
  
  // Create a new IntersectionObserver
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      const cardElement = entry.target;
      const cardIndex = parseInt(cardElement.dataset.index, 10);
      
      if (entry.isIntersecting) {
        // Add visible class
        cardElement.classList.add('visible');
        
        // Update the preview to follow scroll if not actively editing
        if (!editingDraft && lastVisibleCardIdx !== cardIndex) {
          lastVisibleCardIdx = cardIndex;
          // Only update the preview, not selection
          updatePreviewWithoutSelection(cardIndex);
        }
      } else {
        // Remove visible class
        cardElement.classList.remove('visible');
      }
    });
  }, {
    root: $('#cardsList'),
    threshold: 0.7 // 70% of card must be visible
  });
  
  // Observe all card rows
  $$('#cardsList .row').forEach(card => {
    observer.observe(card);
  });
  
  // Store the observer for later cleanup
  window.cardObserver = observer;
}

function updatePreviewWithoutSelection(cardIndex) {
  if (!selectedLevel) return;
  
  const cards = allDecks[selectedLevel] || [];
  if (cardIndex >= 0 && cardIndex < cards.length) {
    const card = cards[cardIndex];
    
    // Update preview without changing selection
    $('#levelBadge').textContent = selectedLevel;
    $('#cardFront').textContent = card.front || '';
    $('#cardBack').textContent = card.back || '';
    $('#cardNotes').textContent = card.notes || '';
    
    // Update progress display
    const totalCards = cards.length;
    const currentCard = cardIndex + 1;
    const percent = totalCards > 0 ? Math.round((currentCard / totalCards) * 100) : 0;
    $('#progressDisplay').textContent = `Cards: ${currentCard}/${totalCards} (${percent}%)`;
    $('#levelDisplay').textContent = `Current Deck: ${selectedLevel}`;
    
    // Add stats
    let statsHtml = '';
    if (card.reading) {
      statsHtml += `Reading: ${card.reading}<br>`;
    }
    
    // Add any other custom fields to stats
    for (const k of Object.keys(card)) {
      if (['front','back','notes','reading'].includes(k)) continue;
      statsHtml += `${k}: ${card[k]}<br>`;
    }
    
    if (statsHtml) {
      $('#cardStats').innerHTML = statsHtml;
      $('#cardStats').style.display = 'block';
    } else {
      $('#cardStats').style.display = 'none';
    }
  }
}
function highlightSelectedRow() {
  $$('#cardsList .row').forEach((r, idx)=> {
    if (idx === selectedCardIndex) {
      r.classList.add('selected');
      
      // Scroll into view if needed
      const list = $('#cardsList');
      const rowTop = r.offsetTop;
      const rowBottom = rowTop + r.offsetHeight;
      const listTop = list.scrollTop;
      const listBottom = listTop + list.offsetHeight;
      
      if (rowTop < listTop) {
        r.scrollIntoView({ behavior: 'smooth', block: 'start' });
      } else if (rowBottom > listBottom) {
        r.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    } else {
      r.classList.remove('selected');
    }
  });
}

function openCardModal(index) {
  isEditExisting = (index !== null && index !== undefined);
  selectedCardIndex = isEditExisting ? index : selectedCardIndex;
  const cards = allDecks[selectedLevel] = allDecks[selectedLevel] || [];
  const card = isEditExisting ? (cards[index] || {}) : {};
  editingDraft = {...card};
  
  // Build fields (front, back, reading, notes + custom)
  const fields = Array.from(new Set([...customFields, ...Object.keys(card||{})]));
  const wrap = $('#cardFields');
  wrap.innerHTML = '';
  
  // two-column grid; make inputs
  fields.forEach(f=>{
    const label = el('label', {}, f.toUpperCase());
    const isTextarea = (f === 'back' || f === 'notes');
    const input = isTextarea ? el('textarea', { value: card[f] || '' }) : el('input', { value: card[f] || '' });
    input.dataset.field = f;
    input.addEventListener('input', ()=>{
      editingDraft[f] = input.value;
      renderPreview(); // live preview while editing
    });
    wrap.appendChild(label);
    wrap.appendChild(input);
  });
  
  $('#cardModalTitle').textContent = isEditExisting ? 'Edit Card' : 'Add Card';
  openModal('cardModalBG');
  setTimeout(()=> (wrap.querySelector('input,textarea')||{}).focus?.(), 30);
}

$('#btnCancelCard').addEventListener('click', ()=> { 
  closeModal('cardModalBG'); 
  editingDraft = null; 
  renderPreview(); 
});

$('#btnSaveCard').addEventListener('click', ()=>{
  if (!selectedLevel) return;
  const wrap = $('#cardFields');
  const inputs = wrap.querySelectorAll('input,textarea');
  const next = {};
  inputs.forEach(inp=>{
    const f = inp.dataset.field;
    const v = inp.value;
    if (v && v.length) next[f] = v;
  });
  
  // Expand custom fields set so future edits keep them visible
  Object.keys(next).forEach(f => customFields.add(f));
  const cards = allDecks[selectedLevel] = allDecks[selectedLevel] || [];
  
  if (isEditExisting && selectedCardIndex >= 0 && selectedCardIndex < cards.length) {
    cards[selectedCardIndex] = next;
  } else {
    cards.push(next);
    selectedCardIndex = cards.length - 1;
  }
  
  closeModal('cardModalBG');
  editingDraft = null;
  renderAll();
  showToast("Card saved successfully!");
});

function deleteCard(i) {
  if (!selectedLevel) return;
  const cards = allDecks[selectedLevel] || [];
  if (!confirm('Delete this card?')) return;
  cards.splice(i, 1);
  if (selectedCardIndex >= cards.length) selectedCardIndex = Math.max(0, cards.length-1);
  editingDraft = null;
  renderAll();
  showToast("Card deleted");
}

function duplicateCard(i) {
  if (!selectedLevel) return;
  const cards = allDecks[selectedLevel] || [];
  cards.splice(i+1, 0, {...cards[i]});
  selectedCardIndex = i+1;
  renderAll();
  showToast("Card duplicated");
}

/* ===== Preview ===== */
$('#deviceSel').addEventListener('change', ()=>{
  const [w, h] = $('#deviceSel').value.split(',').map(x=>parseInt(x, 10));
  updateDeviceSize(w, h);
  renderPreview();
});

function updateDeviceSize(width, height) {
  const container = $('#previewHost');
  const device = $('#device');
  
  // Set the basic dimensions
  device.style.width = width + 'px';
  device.style.height = height + 'px';
  
  // Calculate if we need to scale down to fit viewport
  const hostWidth = container.offsetWidth - 40; // 40px for padding
  const hostHeight = container.offsetHeight - 40;
  
  // If device is bigger than available space, scale it down
  if (width > hostWidth || height > hostHeight) {
    const scaleX = hostWidth / width;
    const scaleY = hostHeight / height;
    const scale = Math.min(scaleX, scaleY);
    
    device.style.transform = `scale(${scale})`;
    device.style.transformOrigin = 'center center';
  } else {
    device.style.transform = 'none';
  }
  
  // Adjust card container size based on device size
  const card = $('#cardContainer');
  card.style.width = Math.min(width * 0.8, width - 40) + 'px';
}

function renderPreview() {
  if (!selectedLevel) {
    // No deck selected state
    $('#levelBadge').textContent = '';
    $('#cardFront').textContent = 'Import a file to start';
    $('#cardBack').textContent = '';
    $('#cardNotes').textContent = '';
    $('#cardStats').textContent = '';
    $('#progressDisplay').textContent = 'Cards: 0/0 (0%)';
    $('#levelDisplay').textContent = 'Current Deck: None';
    $('#showAnswerBtn').style.display = 'block';
    $('#intervalButtons').style.display = 'none';
    return;
  }
  
  const cards = allDecks[selectedLevel] || [];
  
  if (cards.length === 0) {
    // Empty deck
    $('#levelBadge').textContent = selectedLevel;
    $('#cardFront').textContent = 'No cards yet in this deck';
    $('#cardBack').textContent = '';
    $('#cardNotes').textContent = '';
    $('#cardStats').textContent = '';
    $('#progressDisplay').textContent = 'Cards: 0/0 (0%)';
    $('#levelDisplay').textContent = `Current Deck: ${selectedLevel}`;
    $('#showAnswerBtn').style.display = 'block';
    $('#intervalButtons').style.display = 'none';
    return;
  }
  
  const baseCard = (selectedCardIndex >= 0 && cards[selectedCardIndex]) ? cards[selectedCardIndex] : {};
  const card = editingDraft ? {...baseCard, ...editingDraft} : baseCard;
  
  // Update Kindle app UI elements
  $('#levelBadge').textContent = selectedLevel;
  $('#cardFront').textContent = card.front || '';
  $('#cardBack').textContent = card.back || '';
  $('#cardNotes').textContent = card.notes || '';
  
  // Update progress display
  const totalCards = cards.length;
  const currentCard = selectedCardIndex + 1;
  const percent = totalCards > 0 ? Math.round((currentCard / totalCards) * 100) : 0;
  $('#progressDisplay').textContent = `Cards: ${currentCard}/${totalCards} (${percent}%)`;
  $('#levelDisplay').textContent = `Current Deck: ${selectedLevel}`;
  
  // Add stats
  let statsHtml = '';
  if (card.reading) {
    statsHtml += `Reading: ${card.reading}<br>`;
  }
  
  // Add any other custom fields to stats
  for (const k of Object.keys(card)) {
    if (['front','back','notes','reading'].includes(k)) continue;
    statsHtml += `${k}: ${card[k]}<br>`;
  }
  
  if (statsHtml) {
    $('#cardStats').innerHTML = statsHtml;
    $('#cardStats').style.display = 'block';
  } else {
    $('#cardStats').style.display = 'none';
  }
  
  // Show the Show Answer button
  $('#showAnswerBtn').style.display = 'block';
  $('#intervalButtons').style.display = 'none';
}

/* ===== Button Actions ===== */
$('#showAnswerBtn').addEventListener('click', () => {
  $('#showAnswerBtn').style.display = 'none';
  $('#intervalButtons').style.display = 'block';
});

// Interval buttons - these are for the Kindle preview simulation
$$('.intervalBtn').forEach(btn => {
  btn.addEventListener('click', () => {
    // Hide interval buttons and show answer button again
    $('#intervalButtons').style.display = 'none';
    $('#showAnswerBtn').style.display = 'block';

    // In a real app, this would record the interval choice
    const buttonType = btn.className.includes('againBtn') ? 'Again' :
                       btn.className.includes('hardBtn') ? 'Hard' :
                       btn.className.includes('goodBtn') ? 'Good' : 'Easy';

    showToast(`Selected: ${buttonType}`);
  });
});

$('#starButton').addEventListener('click', () => {
  const button = $('#starButton');
  if (button.textContent === '☆') {
    button.textContent = '★';
    button.classList.add('starred');
  } else {
    button.textContent = '☆';
    button.classList.remove('starred');
  }
});

/* ===== Window resize handler ===== */
window.addEventListener('resize', () => {
  const [w, h] = $('#deviceSel').value.split(',').map(x=>parseInt(x, 10));
  updateDeviceSize(w, h);
});

/* ===== State Persistence ===== */
function initializeFromStorage() {
  let raw;
  try { 
    raw = localStorage.getItem('kanki_editor_state'); 
  } catch (e) { 
    hasInitialized = true; return; 
  }
  if (raw) {
    try { var state = JSON.parse(raw); } catch (e) { hasInitialized = true; return; }
    allDecks = typeof state.allDecks === 'object' && state.allDecks ? state.allDecks : {};
    levels = Array.isArray(state.levels) ? state.levels : [];
    selectedLevel = typeof state.selectedLevel === 'string' && state.selectedLevel ? state.selectedLevel : '';
    importedFileName = typeof state.importedFileName === 'string' && state.importedFileName ? state.importedFileName : 'kanki_config.js';
    importedLanguage = typeof state.importedLanguage === 'string' && state.importedLanguage ? state.importedLanguage : 'Deck';
  }
  hasInitialized = true;
}

function saveToStorage() {
  try {
    localStorage.setItem('kanki_editor_state', JSON.stringify({
    allDecks,
    levels,
    selectedLevel,
    importedFileName,
    importedLanguage
  }));
  } catch (e) {
    return;
  }
}

/* ===== New Helper Functions ===== */

// Update status bar
function updateStatusBar() {
  const cards = allDecks[selectedLevel] || [];
  const total = cards.length;
  const filtered = cards.filter(card => matchesSearch(card, searchQuery)).length;

  if (searchQuery && filtered < total) {
    $('#statusCount').textContent = `${filtered} of ${total} cards`;
    $('#statusFilter').textContent = `Filter: "${searchQuery}"`;
  } else {
    $('#statusCount').textContent = `${total} card${total !== 1 ? 's' : ''}`;
    $('#statusFilter').textContent = '';
  }
}

// Update bulk actions bar
function updateBulkActions() {
  const bulkBar = $('#bulkActions');
  const count = selectedCards.size;

  if (count > 0) {
    bulkBar.classList.add('active');
    $('#bulkCount').textContent = `${count} selected`;
  } else {
    bulkBar.classList.remove('active');
  }
}

// Reorder card via drag and drop
function reorderCard(fromIndex, toIndex) {
  if (!selectedLevel || fromIndex === toIndex) return;

  const cards = allDecks[selectedLevel];
  const [movedCard] = cards.splice(fromIndex, 1);
  cards.splice(toIndex, 0, movedCard);

  // Update selected index if needed
  if (selectedCardIndex === fromIndex) {
    selectedCardIndex = toIndex;
  } else if (fromIndex < selectedCardIndex && toIndex >= selectedCardIndex) {
    selectedCardIndex--;
  } else if (fromIndex > selectedCardIndex && toIndex <= selectedCardIndex) {
    selectedCardIndex++;
  }

  draggedCardIndex = -1;
  renderAll();
  showToast('Card reordered');
}

// Select all cards
function selectAllCards() {
  if (!selectedLevel) return;
  const cards = allDecks[selectedLevel] || [];
  selectedCards.clear();
  cards.forEach((_, i) => selectedCards.add(i));
  renderCards();
  showToast(`${selectedCards.size} cards selected`);
}

// Deselect all cards
function deselectAllCards() {
  selectedCards.clear();
  renderCards();
}

// Bulk duplicate
function bulkDuplicate() {
  if (!selectedLevel || selectedCards.size === 0) return;

  const cards = allDecks[selectedLevel];
  const toDuplicate = Array.from(selectedCards).sort((a, b) => b - a);

  toDuplicate.forEach(i => {
    if (i < cards.length) {
      cards.splice(i + 1, 0, {...cards[i]});
    }
  });

  selectedCards.clear();
  renderAll();
  showToast(`${toDuplicate.length} card${toDuplicate.length !== 1 ? 's' : ''} duplicated`);
}

// Bulk delete
function bulkDelete() {
  if (!selectedLevel || selectedCards.size === 0) return;

  const count = selectedCards.size;
  if (!confirm(`Delete ${count} selected card${count !== 1 ? 's' : ''}?`)) return;

  const cards = allDecks[selectedLevel];
  const toDelete = Array.from(selectedCards).sort((a, b) => b - a);

  toDelete.forEach(i => {
    if (i < cards.length) {
      cards.splice(i, 1);
    }
  });

  selectedCards.clear();
  if (selectedCardIndex >= cards.length) {
    selectedCardIndex = Math.max(0, cards.length - 1);
  }

  renderAll();
  showToast(`${count} card${count !== 1 ? 's' : ''} deleted`);
}

/* ===== Render root ===== */
function renderAll() {
  if (!hasInitialized) {
    initializeFromStorage();
  }

  renderDecks();
  renderCards();
  renderPreview();
  $('#btnExport').disabled = levels.length === 0;
  $('#btnAddCard').disabled = !selectedLevel;
  saveToStorage();
  
  // Make sure device size is correct
  const [w, h] = $('#deviceSel').value.split(',').map(x=>parseInt(x, 10));
  updateDeviceSize(w, h);
}

/* ===== Event Listeners ===== */

// Search functionality
$('#searchInput').addEventListener('input', (e) => {
  searchQuery = e.target.value.trim();
  const clearBtn = $('#btnClearSearch');

  if (searchQuery) {
    clearBtn.style.display = 'block';
  } else {
    clearBtn.style.display = 'none';
  }

  renderCards();
});

$('#btnClearSearch').addEventListener('click', () => {
  searchQuery = '';
  $('#searchInput').value = '';
  $('#btnClearSearch').style.display = 'none';
  renderCards();
});

// Bulk action buttons
$('#btnBulkDuplicate').addEventListener('click', bulkDuplicate);
$('#btnBulkDelete').addEventListener('click', bulkDelete);
$('#btnDeselectAll').addEventListener('click', deselectAllCards);

// Dropdown menu handling
(function() {
  const menuItems = $$('.menu-item');

  menuItems.forEach(menuItem => {
    const menuTitle = menuItem.querySelector('span');

    menuTitle.addEventListener('click', (e) => {
      e.stopPropagation();

      // Close all other menus
      menuItems.forEach(item => {
        if (item !== menuItem) {
          item.classList.remove('active');
        }
      });

      // Toggle this menu
      menuItem.classList.toggle('active');
    });
  });

  // Close dropdowns when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.menu-item')) {
      menuItems.forEach(item => item.classList.remove('active'));
    }
  });

  // Close dropdown after clicking a menu item
  const dropdownItems = $$('.menu-dropdown-item');
  dropdownItems.forEach(item => {
    item.addEventListener('click', () => {
      menuItems.forEach(menu => menu.classList.remove('active'));
    });
  });
})();

// Menu bar actions
$('#menuImport').addEventListener('click', () => $('#fileInput').click());
$('#menuExport').addEventListener('click', () => $('#btnExport').click());
$('#menuAddCard').addEventListener('click', () => {
  if (!$('#btnAddCard').disabled) $('#btnAddCard').click();
});
$('#menuDuplicateCard').addEventListener('click', () => {
  if (selectedCardIndex >= 0) duplicateCard(selectedCardIndex);
});
$('#menuDeleteCard').addEventListener('click', () => {
  if (selectedCardIndex >= 0) deleteCard(selectedCardIndex);
});
$('#menuSelectAll').addEventListener('click', selectAllCards);
$('#menuDeselectAll').addEventListener('click', deselectAllCards);
$('#menuToggleTheme').addEventListener('click', () => {
  $('.theme-toggle').click();
});
$('#menuSearch').addEventListener('click', () => {
  $('#searchInput').focus();
  $('#searchInput').select();
});
$('#menuShortcuts').addEventListener('click', () => {
  const help = $('#shortcutHelp');
  help.classList.toggle('show');
  setTimeout(() => help.classList.remove('show'), 5000);
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Don't trigger shortcuts when typing in input fields
  const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
  const modalOpen = document.querySelector('.modalBG.active');

  // Escape key - close modals or clear selection
  if (e.key === 'Escape') {
    if (modalOpen) return; // Let modal handlers deal with it
    deselectAllCards();
    searchQuery = '';
    $('#searchInput').value = '';
    $('#btnClearSearch').style.display = 'none';
    renderCards();
    return;
  }

  // Ctrl/Cmd + N - New card
  if ((e.ctrlKey || e.metaKey) && e.key === 'n' && !isInput) {
    e.preventDefault();
    if (!$('#btnAddCard').disabled) $('#btnAddCard').click();
    return;
  }

  // Ctrl/Cmd + D - Duplicate card
  if ((e.ctrlKey || e.metaKey) && e.key === 'd' && !isInput) {
    e.preventDefault();
    if (selectedCardIndex >= 0) duplicateCard(selectedCardIndex);
    return;
  }

  // Delete key - Delete card
  if (e.key === 'Delete' && !isInput) {
    e.preventDefault();
    if (selectedCardIndex >= 0) deleteCard(selectedCardIndex);
    return;
  }

  // Ctrl/Cmd + S - Export
  if ((e.ctrlKey || e.metaKey) && e.key === 's' && !isInput) {
    e.preventDefault();
    if (!$('#btnExport').disabled) $('#btnExport').click();
    return;
  }

  // Ctrl/Cmd + O - Import
  if ((e.ctrlKey || e.metaKey) && e.key === 'o' && !isInput) {
    e.preventDefault();
    $('#fileInput').click();
    return;
  }

  // Ctrl/Cmd + F - Search
  if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
    e.preventDefault();
    $('#searchInput').focus();
    $('#searchInput').select();
    return;
  }

  // Ctrl/Cmd + A - Select all cards
  if ((e.ctrlKey || e.metaKey) && e.key === 'a' && !isInput) {
    e.preventDefault();
    selectAllCards();
    return;
  }

  // Ctrl/Cmd + T - Toggle theme
  if ((e.ctrlKey || e.metaKey) && e.key === 't' && !isInput) {
    e.preventDefault();
    $('.theme-toggle').click();
    return;
  }

  // ? - Show shortcuts help
  if (e.key === '?' && !isInput) {
    e.preventDefault();
    const help = $('#shortcutHelp');
    help.classList.toggle('show');
    setTimeout(() => help.classList.remove('show'), 5000);
    return;
  }

  // Arrow keys - Navigate cards
  if (!isInput && !modalOpen) {
    const cards = allDecks[selectedLevel] || [];
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (selectedCardIndex < cards.length - 1) {
        selectedCardIndex++;
        renderPreview();
        highlightSelectedRow();
      }
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (selectedCardIndex > 0) {
        selectedCardIndex--;
        renderPreview();
        highlightSelectedRow();
      }
    }
  }
});

/* ===== First load: prompt import ===== */
window.addEventListener('load', () => {
  setTimeout(() => {
    $('#fileInput').click();
    renderAll(); // Initialize UI

    // Check APKG support and update UI
    checkAndUpdateAPKGSupport();
  }, 400);
});

// Check if APKG import is supported and update UI accordingly
function checkAndUpdateAPKGSupport() {
  const isSupported = checkAPKGSupport();

  if (!isSupported) {
    console.warn('APKG import is not supported in this browser');
    console.info('Browser compatibility:');
    console.info('- File.arrayBuffer:', typeof File.prototype.arrayBuffer !== 'undefined' ? '✓' : '✗');
    console.info('- JSZip library:', typeof JSZip !== 'undefined' ? '✓' : '✗');
    console.info('- sql.js library:', typeof initSqlJs !== 'undefined' ? '✓' : '✗');
    console.info('- WebAssembly:', typeof WebAssembly !== 'undefined' ? '✓' : '✗');

    // Update file input to only accept .js files
    const fileInput = $('#fileInput');
    if (fileInput) {
      fileInput.setAttribute('accept', '.js');
    }
  } else {
    console.info('✓ APKG import is supported - you can import Anki decks!');
  }
}

// Ensure theme toggle button works (fallback if theme-toggle.js fails)
(function initThemeToggleFallback() {
  const themeToggleBtn = $('.theme-toggle');
  if (themeToggleBtn && !themeToggleBtn.hasAttribute('data-initialized')) {
    themeToggleBtn.setAttribute('data-initialized', 'true');

    // Initialize theme from localStorage
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'light') {
      document.documentElement.setAttribute('data-theme', 'light');
    }

    // Add click handler as fallback
    const toggleThemeHandler = () => {
      const root = document.documentElement;
      const currentTheme = root.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';

      if (newTheme === 'light') {
        root.setAttribute('data-theme', 'light');
      } else {
        root.removeAttribute('data-theme');
      }

      localStorage.setItem('theme', newTheme);
      showToast(`Switched to ${newTheme} mode`);
    };

    themeToggleBtn.addEventListener('click', toggleThemeHandler);
  }
})();
</script>

</body>
</html>